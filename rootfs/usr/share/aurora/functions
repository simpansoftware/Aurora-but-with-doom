#!/bin/bash

export COLOR_RESET="\e[0m"
export BLACK_B="\e[1;30m"
export RED_B="\e[1;31m"
export GEEN="\e[0;32m"
export GEEN_B="\e[1;32m"
export YELLOW="\e[0;33m"
export YELLOW_B="\e[1;33m"
export BLUE_B="\e[1;34m"
export MAGENTA_B="\e[1;35m"
export LIGHT_BLUE_B="\e[1;38;5;81m"
export PINK_B="\e[1;38;5;213m"
export PURPLE_B="\e[1;38;5;55m"
export ORANGE_B="\e[1;38;5;202m"
export CYAN_B="\e[1;38;5;36m"

hang() {
	tput civis
	stty -echo
	sleep 1h
	echo "You really still haven't turned off your device?" | center
	sleep 1d
	echo "I give up. Bye" | center
	sleep 5
	reboot -f
}

fail() {
    export errormsg="$1"
	sync
    cd /
    umount /dev/loop*p* 2>/dev/null
    umount /dev/loop* 2>/dev/null
	losetup -D
    for arg in "$@"; do
        if [ "$arg" = "--fatal" ]; then
            echo_c "A fatal error occured. Please Reboot" RED_B | center
            hang
        fi
    done
    return 1
}
export -f fail

canwifi() {
  if curl -Is https://nebulaservices.org | head -n 1 | grep -q "HTTP/"; then # the website with the best uptime is good for this usecase!
    "$@"
  else
    echo "Nebula Services is down. Trying example.com..." | center
    if curl -Is https://example.com | head -n 1 | grep -q "HTTP/"; then
        "$@"
    else
        fail "Not connected to the internet"
    fi
  fi
}

echo_c() {
    local text="$1"
    local color_variable="$2"
    local color="${!color_variable}"
    echo -e "${color}${text}${COLOR_RESET}"
}

center() {
    local width=$(tput cols)
    local offset="${1:-0}"

    while IFS= read -r line || [[ -n $line ]]; do
        local plain=$(echo -e "$line" | sed -E 's/\e\[[0-9;]*[mK]//g')
        local len=${#plain}
        local pad=$(( (width - len) / 2 + offset ))
        (( pad < 0 )) && pad=0
        printf "%*s%s\n" "$pad" "" "$line"
    done
}
export -f center
read_center() {
    local dynamic=0
    if [[ "$1" == "-d" ]]; then
        dynamic=1
        shift
    fi

    local prompt="$1"
    local readvar="$2"
    local offset="${3:-0}"
    local width=$(tput cols)

    local plain=$(echo -e "$prompt" | sed -E 's/\e\[[0-9;]*[mK]//g')
    local plen=${#plain}
    local pad=$(( (width - plen) / 2 + offset ))
    (( pad < 0 )) && pad=0

    if (( ! dynamic )); then
        printf "%*s%s" "$pad" "" "$prompt"
        if [[ -n "$readvar" ]]; then
            read -r "$readvar"
        else
            read -r
        fi
    else
        printf "%*s%s" "$pad" "" "$prompt"

        local input=""
        local char=""
        local ilen=0
        local nowrap=1

        local stty=$(stty -g)
        stty -icanon -echo

        while IFS= read -rsn1 char; do
            if [[ -z $char ]]; then
                break
            elif [[ $char == $'\x7f' || $char == $'\x08' || $char == $'\b'  || $char == '^H' ]]; then
                if [[ -n $input ]]; then
                    input="${input::-1}"
                    ((ilen--))
                    tput cr
                    tput el
                    local pad=$(( (width - plen - ilen) / 2 + offset ))
                    (( pad < 0 )) && pad=0
                    printf "%*s%s%s" "$pad" "" "$prompt" "$input"
                fi
            elif [[ $char == $'\e' ]]; then
                read -rsn2 discard
                continue
            else
                input+="$char"
                ((ilen++))

                if (( nowrap && (plen + ilen >= width) )); then
                    nowrap=0
                    echo -n "$char"
                elif (( nowrap )); then
                    tput cr
                    tput el
                    local pad=$(( (width - plen - ilen) / 2 + offset ))
                    (( pad < 0 )) && pad=0
                    printf "%*s%s%s" "$pad" "" "$prompt" "$input"
                else
                    echo -n "$char"
                fi
            fi
        done
        echo ""
        if [[ -n "$readvar" ]]; then
            printf -v "$readvar" '%s' "$input"
        fi
        stty "$stty"
    fi
}
export -f read_center